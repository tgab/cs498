function Main.main 2
// Compiling statements
// Do statement
// Compiling expression list
push constant 8001
here
push constant 16
here
push constant 1
here
neg
call Main.fillMemory 3
// Let statement
push local 1
<identifier> Memory CAT=VAR USED=true </identifier>
// Compiling expression list
push constant 8000
here
call Memory.peek 1
pop local 1
// Do statement
// Compiling expression list
<identifier> value CAT=VAR USED=true </identifier>
push local 1
here
call Main.convert 1
// Return statement
push constant 0
return
<keyword> int </keyword>
<identifier> value CAT=ARG USED=false </identifier>
</parameterList>
<symbol> ) </symbol>
function Main.convert 1
// Compiling statements
// Let statement
push local 2
<keyword> true </keyword>
here
pop local 2
// While statement
<keyword> while </keyword>
<symbol> ( </symbol>
<identifier> loop CAT=VAR USED=true </identifier>
push local 2
here
<symbol> ) </symbol>
<symbol> { </symbol>
// Compiling statements
// Let statement
push local 1
<identifier> position CAT=VAR USED=true </identifier>
push local 1
here
push constant 1
here
add
pop local 1
// Let statement
push local 0
<identifier> Main CAT=VAR USED=true </identifier>
// Compiling expression list
<identifier> mask CAT=VAR USED=true </identifier>
push local 0
here
call Main.nextMask 1
pop local 0
// Do statement
// Compiling expression list
push constant 9000
here
<identifier> position CAT=VAR USED=true </identifier>
push local 1
here
add
<identifier> mask CAT=VAR USED=true </identifier>
push local 0
here
call Memory.poke 2
// If statement
<keyword> if </keyword>
<symbol> ( </symbol>
<identifier> position CAT=VAR USED=true </identifier>
push local 1
here
push constant 16
here
gt
not
<symbol> ) </symbol>
<symbol> { </symbol>
// Compiling statements
// If statement
<keyword> if </keyword>
<symbol> ( </symbol>
<identifier> value CAT=VAR USED=true </identifier>
push argument 1
here
<identifier> mask CAT=VAR USED=true </identifier>
push local 0
here
and
push constant 0
here
eq
not
<symbol> ) </symbol>
<symbol> { </symbol>
// Compiling statements
// Do statement
// Compiling expression list
push constant 8000
here
<identifier> position CAT=VAR USED=true </identifier>
push local 1
here
add
push constant 1
here
call Memory.poke 2
<symbol> } </symbol>
<keyword> else </keyword>
<symbol> { </symbol>
// Compiling statements
// Do statement
// Compiling expression list
push constant 8000
here
<identifier> position CAT=VAR USED=true </identifier>
push local 1
here
add
push constant 0
here
call Memory.poke 2
<symbol> } </symbol>
<symbol> } </symbol>
<keyword> else </keyword>
<symbol> { </symbol>
// Compiling statements
// Let statement
push local 2
<keyword> false </keyword>
here
pop local 2
<symbol> } </symbol>
<symbol> } </symbol>
// Return statement
push constant 0
return
<keyword> int </keyword>
<identifier> mask CAT=ARG USED=false </identifier>
</parameterList>
<symbol> ) </symbol>
function Main.nextMask 1
// Compiling statements
// If statement
<keyword> if </keyword>
<symbol> ( </symbol>
<identifier> mask CAT=VAR USED=true </identifier>
push argument 1
here
push constant 0
here
eq
<symbol> ) </symbol>
<symbol> { </symbol>
// Compiling statements
// Return statement
push constant 1
here
<symbol> } </symbol>
<keyword> else </keyword>
<symbol> { </symbol>
// Compiling statements
// Return statement
<identifier> mask CAT=VAR USED=true </identifier>
push argument 1
here
push constant 2
here
call Math.multiply 2
<symbol> } </symbol>
<keyword> int </keyword>
<identifier> startAddress CAT=ARG USED=false </identifier>
<symbol> , </symbol>
<keyword> int </keyword>
<identifier> length CAT=ARG USED=false </identifier>
<symbol> , </symbol>
<keyword> int </keyword>
<identifier> value CAT=ARG USED=false </identifier>
</parameterList>
<symbol> ) </symbol>
function Main.fillMemory 3
// Compiling statements
// While statement
<keyword> while </keyword>
<symbol> ( </symbol>
<identifier> length CAT=VAR USED=true </identifier>
push argument 2
here
push constant 0
here
gt
<symbol> ) </symbol>
<symbol> { </symbol>
// Compiling statements
// Do statement
// Compiling expression list
<identifier> startAddress CAT=VAR USED=true </identifier>
push argument 1
here
<identifier> value CAT=VAR USED=true </identifier>
push argument 3
here
call Memory.poke 2
// Let statement
push argument 2
<identifier> length CAT=VAR USED=true </identifier>
push argument 2
here
push constant 1
here
sub
pop argument 2
// Let statement
push argument 1
<identifier> startAddress CAT=VAR USED=true </identifier>
push argument 1
here
push constant 1
here
add
pop argument 1
<symbol> } </symbol>
// Return statement
push constant 0
return
